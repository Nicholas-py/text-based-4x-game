from collections import deque
class FamilyRelation:
    maxsearch = 3
    def __init__(self, p1, p2):
        
        self.p1 = p1
        self.p2 = p2
        self.commonancestor,self.inlaw = FamilyRelation.getCommonAncestor(p1,p2)
        self.p1gens, self.p2gens = self.getGensToAncestor(self.p1), self.getGensToAncestor(self.p2)
        
    def applies(p1,p2):
        return FamilyRelation.getCommonAncestor(p1,p2) is not None

    def getGensToAncestor(self, person):
        queue = deque([(person,0)])
        while len(queue) > 0:
            nextperson, depth = queue.popleft()
            depth += 1
            if depth <= FamilyRelation.maxsearch:
                if nextperson == self.commonancestor:
                    return depth-1
                else:
                    queue.append((nextperson.parents[0],depth))
                    queue.append((nextperson.parents[1],depth))
    
    def getCommonAncestor(p1,p2):
        indices = {}
        queue = deque([(p1,0,False),(p2,0,False)])
        while len(queue) > 0:
            nextperson, depth, inlaw = queue.popleft()
            depth += 1
            if depth <= FamilyRelation.maxsearch:
                if nextperson.index in indices:
                    return nextperson, inlaw
                indices[nextperson.index] = nextperson
                for i in nextperson.parents:
                    if i is not None:
                        queue.append((i,depth, inlaw))
                if nextperson.spouse is not None and not inlaw:
                    queue.append((nextperson.spouse,depth,True))
        return None
    
    #relation from p1 to p2, reversed is from p2 to p1
    def getrelationname(self,from_person=None):
        hir = {'M':'his ','F':'her '}[from_person.gender]

        if self.inlaw:
            pass
        else:
            if from_person == self.p1 or from_person is None:
                p1,p2,p1gens,p2gens = self.p1,self.p2,self.p1gens,self.p2gens
            elif from_person == self.p2:
                p1,p2,p1gens,p2gens = self.p2,self.p1,self.p2gens,self.p1gens
            else:
                raise Exception("person not member of relation")

            grid = [[['the same person']*2,       ['father','mother'], ['grandfather','grandmother'],['great-grandfather','great-grandmother']],
                    [['son','daughter'],          ['brother','sister'],['uncle','aunt'],['great-uncle','great-aunt']],
                    [['grandson','granddaughter'],['nephew','niece'],  ['cousin','cousin'], ['first cousin once removed']*2],
                    [['great-grandson','great-granddaughter'],['grandnephew','grandniece'],['first cousin once removed']*2,['second cousin']*2]]
            val = grid[p2gens][p1gens][{'M':0,'F':1}[p2.gender]]
            if p1gens!= 0 or p2gens != 0:
                val = hir + val
            return val

    def __repr__(self):
        return self.getrelationname()

from person import Person
gp1, gp2, gp3, gp4 = Person(), Person(), Person(), Person()
gp1.marry(gp2); gp3.marry(gp4)
print(gp1.name, '+',gp2.name,'     ',gp3.name,'+',gp4.name)
parent1,parent2,parent3 = (gp1.havechildwith(gp2),gp1.havechildwith(gp2),gp3.havechildwith(gp4))
print(parent1.name)
print('and')
print(parent3.name)
print('had a child:')
child = (parent1.havechildwith(parent3))
child2 = (parent2.havechildwith(Person()))
print(child.name)
x,y = parent1, parent2
a = (FamilyRelation(x, y))
print(x.name,': ',y.name,a.getrelationname(x))
print(child)
